# shell-with-auth-ngrx
[![Build Status](https://travis-ci.com/yiqu/shell-with-auth-ngrx.svg?branch=master)](https://travis-ci.com/yiqu/shell-with-auth-ngrx)

This is a shell application that uses Firebase Fire Store as the database, and NgRx as the state manager.

Latest: [Github Pages](https://yiqu.github.io/shell-with-auth-ngrx)

Stable: [Firebase Hosted](https://kq-1-1a499.web.app/)

## Using this shell

### Link up your Firebase backend

First we need to configure the project with your own Firebase backend configuration. Replace the Firebase config in environment.ts file with your own Firebase config.

```
firebaseConfig: {
    apiKey: xxx
    authDomain: xxx
    databaseURL: xxx
    projectId: xxx
    storageBucket: xxx
    messagingSenderId: xxx
    appId: xxx
}
```
This config can be found in your Firebase Console's project page.
Remove .firebaserc file and firebase.json. These two files are generated by running the deployment initializtion steps.

### Replace the PLACEHOLDER name entity

There is a PLACEHOLDER name that will need to be changed. Just CTRL+F for PLACEHOLDER and replace the String with your app's name.

### Firebase User Model

When a user register for an account, first this shell will register the user into Firebase. Second, it will then create a entry
in the Firestore database with the follow model:

```
export class VerifiedUser {
  constructor(
    public createdAt: string,
    public displayName: string,
    public email: string,
    public emailVerified: string,
    public isAnonymous: string,
    public lastLoginAt: string,
    public photoURL: string,
    public providerData: ProviderData[],
    public stsTokenManager: any,
    public tenantId: string,
    public uid: string,
    public phoneNumber: string,
    public inAppAliases: InAppAlias,
    public logins: string[]
  ) {
  }

}
```

The user will be stored in Firestore under the path of  /users/userId.

### Firestore Rules

Rules should be at least like the following:

```
service cloud.firestore {
  match /databases/{database}/documents {


    match /users/{userId} {
    	allow read;
      allow write: if request.auth.uid == userId;
    }
    
    match /{userId}/{document=**} {
    	allow read: if request.auth.uid == userId;
      allow write: if request.auth.uid == userId;
    }
  }
}
```

This will only allow user read/write their own documents after signing in.


### Firebase Auth Across Tabs Behavior

Expected behavior across browser tabs

The following expected behavior will apply when different persistence types are used in different tabs. The requirement is that at any point, there should never be multiple types of saved states at the same time (eg. auth state saved in session and local types of storage):

* Users can sign in using session or none persistence with different users on multiple tabs. Each tab cannot see the state of the other tab.

* Any attempt to sign in using local persistence will be detected and synchronized on all tabs. If the user was previously signed in on a specific tab using session or none persistence, that state will be cleared.

* If the user was previously signed in using local persistence with multiple tabs opened and then switches to none or session persistence in one tab, the state of that tab will be modified with the user persisted in session or none and on all other tabs, the user will be signed out.


### Host your app on Firebase

```
firebase login
```

```
firebase init
```

```
firebase deploy
```


